---
layout: default
section: faq
breadcrumbs: hidden
title: Iron.io Frequently Asked Questions
---

<small>This a compilation of helpful answers to frequently asked questions. If you don't see your question on here, fear not! Just send us an [email](mailto:support@iron.io) and we'll get back you shortly.
	The Iron Team also encourages you to <a href="/community/docs/">contribute</a> to our documentation.</small>

<h2 id="IronHUD-faq"> <a href="http://hud.iron.io">Iron Heads Up Display</a> </h2>
<ul>
<li><a href ="#HUDfaq-1">How do I share my Project/Account with others?</a></li>

</ul>
<h2 id="IronMQ-faq">IronMQ</h2>
<ul>
<li><a href ="#MQfaq-1">What is IronMQ?</a></li>
<li><a href ="#MQfaq-2">What can I do with IronMQ?</a></li>
<li><a href ="#MQfaq-3">How do I get started with IronMQ?</a></li>
<li><a href ="#MQfaq-4">What resources are available on IronMQ?</a></li>
<li><a href="#MQfaq-5">What are the benefits of IronMQ vs self-managed message queues?</a></li>
<li><a href ="#MQfaq-6">What are the benefits of IronMQ vs RabbitMQ?</a></li>
<li><a href ="#MQfaq-7">What are the benefits of IronMQ vs SQS?</a></li>
<li><a href ="#MQfaq-8">What happens to messages if no clients pull them off after put?</a></li>
<li><a href ="#MQfaq-9">Why are GETs and DELETEs separate actions? </a></li>
<li><a href ="#MQfaq-10">What is a push queue?</a></li>
<li><a href ="#MQfaq-11">What is the difference between unicast and multicast?</a></li>
<li><a href ="#MQfaq-12">Is the retry limit on unicast based on individual push attempt?</a></li>
<li><a href ="#MQfaq-13">Can a queue be a push queue and a pull queue at the same time?</a></li>
<li><a href ="#MQfaq-14">What security measures are used within IronMQ?</a></li>
</ul>

<h2 id="IronWorker-faq">IronWorker</h2>
<ul>
<li><a href="#Workerfaq-1">What is IronWorker?</a></li>
<li><a href="#Workerfaq-2">What client libraries are available for IronWorker?</a></li>
<li><a href="#Workerfaq-3">What are the advantages of IronWorker vs Heroku Workers, Celery, or Resque?</a> </li>
<li><a href="#Workerfaq-4">I'm getting this error "zip/zip (LoadError)"</a></li>
<li><a href="#Workerfaq-5">How do I access my worker's logs and what is printed in them?</a></li>
</ul>

<h2 id="IronCache-faq" >IronCache</h2>
<ul>
<li><a href="#Cachefaq-1">What is IronCache?</a></li>
</ul>

<div id="HUDfaq-1">
<h3> How do I share my Project/Account? </h3>

<p>Sharing your Project by simply clicking on the share icon in our heads up display. If the user has an account they will immediately see your project otherwise a invite will be sent our asking them to join yours. </p>

<a href="/images/faq/project-sharing.png"><img src="/images/faq/project-sharing.png" alt="how to share projects on iron hud iron.io" class="faq-image"></a>
<a href="/images/faq/project-sharing2.png"><img src="/images/faq/project-sharing2.png" alt="how to share projects on iron hud iron.io" class="faq-image"></a>
</div>


<div id="MQfaq-1">
<h3> What is IronMQ? </h3>
<p>IronMQ is an elastic message queue created specifically with the cloud in mind. It’s easy to use, runs on industrial-strength cloud infrastructure, and offers developers ready-to-use messaging with highly reliable delivery options and cloud-optimized performance.  </p>
</div>

<div id="MQfaq-2">
<h3>What can I do with IronMQ?</h3>
<p>A messaging layer is key to creating reliable and scalable distributed systems. It lets you orchestrate and manage the volume of messages and events that flow within your application and between other applications, sites, and services. IronMQ is a cloud-based solution that eliminates any setup or maintenance and provides work dispatch, load buffering, synchronicity, database offloading, and many other core needs for scalable cloud applications.</p></div>

<div id="MQfaq-3">
<h3>How do I get started with IronMQ?</h3>
<p>Users can get up and running in a few minutes. Just sign up and get an auth token, and then you can send and receive messages on one or more queues. It’s that simple. Iron offers a free full-feature 14 day trial with no credit card required and so it’s easy to build in message queuing right from the start.</p></div>

<div id="MQfaq-4">
<h3>What resources are available on IronMQ?</h3>
<p>See our developer section for information on how IronMQ works, API reference guide and other technical details. There are also a growing list of <a href="/mq/3/libraries/">client libraries</a> and framework integrations. These cover most common languages as well as frameworks such as Celery, YII, Laravel, DelayedJob and others. </p>
</div>

<div id="MQfaq-5">
<h3>What are the benefits of IronMQ vs self-managed message queues?</h3>
<p>Cloud services provide many advantages over standing up software on self-managed servers. Primary ones include reduced complexity, greater speed to market, and increased reliability and scalability.

It’s reasonably easy to stand up an open-source message queuing solution on a single virtual server but it’s exceedingly difficult to make a queuing system highly scalable and reliable. It takes multiple instances across zones or regions and redundancy within every layer and component including load balancing and the persistence layer. Robust logging and introspection tools add additional complexity. Multiply this across multiple environments, applications, systems, and business units, and the task of operating self-managed queues becomes almost impossible.</p></div>

<div id="MQfaq-6">
<h3>What are the benefits of IronMQ vs RabbitMQ?</h3>
<p>RabbitMQ is an open-source packaged based on the AMQP protocol. It’s a strong messaging standard that has a lot of backing and inertia behind it. Unfortunately, it’s built for a different time – one that is pre-cloud and behind the firewall. It requires a lot of work to scale and make redundant and is more complex than most developers need.

IronMQ is based on HTTP, takes JSON packages, and uses OAuth for authentication – all protocols and standards that are well-known to cloud developers. AMQP is a separate application layer protocol that is different than the one developers are used to using on a daily basis.

AMQP also uses a less common default socket as part of the transport layer. Whereas certain cloud application hosts don’t allow most socket connections from within their sandbox, they do allow HTTP requests. HTTP and HTTPS are always open on most enterprise firewalls, but special ports may not always be. Everyone can easily speak HTTP, but it takes special effort to speak AMQP. This greatly limits the environments into which AMQP can be deployed.

For more information on the differences between IronMQ and RabbitMQ, please see the 
<a href="http://www.iron.io/mq/comparison/">comparison matrix</a> on the website.</p></div>

<div id="MQfaq-7">
<h3>What are the benefits of IronMQ vs SQS?</h3>
<p>For more information on the differences between IronMQ and SQS, please see the <a href="http://www.iron.io/mq#comparison">comparison matrix</a> on the website.</p>
</div>

<div id="MQfaq-8">
<h3>What happens to messages if no clients pull them off after putting them in the queue? </h3>
<p>Messages will persist in the queue until a receiver takes them off.</p>
</div>


<div id="MQfaq-9">
<h3>Why are GETs and DELETEs separate actions? </h3>
<p>Receiving a message (GET) and deleting a message (DELETE) are separate actions because it provides a reliable paradigm for processing messages. An explicit delete protects messages from being only partially processed. If the receiving process dies or encounters an error, the message will be automatically put back on the queue once the timeout is reached.
</p>
<aside>Note that with push queues, messages are deleted from the queue once a successful push takes place. (Messages can be retried multiple times.)</aside></div>

<div id="MQfaq-10">
<h3>What is a push queue?</h3>
<p>A push queue is a queue that automatically pushes messages to endpoints. These endpoints can be HTTP/REST endpoints, IronMQ endpoints (in the form of a webhook), or an IronWorker endpoint (also in the form of a webhook). After a succesful push, messages are automatically deleted from the message queue. </p></div>

<div id="MQfaq-11">
<h3>What is the difference between unicast and multicast?</h3>
<p>Unicast is a routing pattern that will cycle through the endpoints pushing to one endpoint after another until a success push occurs.

Multicast is a routing pattern that will push the messages to all the subscribers.</p></div>

<div id="MQfaq-12">
<h3>Is the retry limit on unicast based on individual push attempts or based on the number of cycles of pushes?</h3>
<p>
It is transient so events and the associated data only exists until it has been delivered to all connected clients. If there are no clients subscribed to the channel that the message has been triggered on then that event is instantly lost.

At present, we do not persist messages beyond the timeout value (default or user-set).</p>
</div>

<div id="MQfaq-13">
<h3>Can a queue be a push queue and a pull queue at the same time?</h3>
<p>No. Queues are either on or the other (messages don’t last long on a push queue). You can switch from a pull queue to a push queue and vice versa at any point. (For example, to turn a push queue into a pull queue,you would just send push_type : pull.) Messages on a push queue at the time of a change will remain on the queue.

You can also make a pull queue a subscriber of a push queue – either statically or by adding/deleting subscribers dynamically. (Just add the webhook endpoint for the pull queue as a subscriber for the push queue.)
</p>
</div>

<div id="MQfaq-14">
<h3>What security measures are used within IronMQ?</h3>
<p>Iron.io services run on top of industrial-strength clouds such as AWS and Rackspace and so we inherit many of their security measures and certifications that these clouds offer regarding VM security, network security, and physical security.

Strong authentication using OAuth is provided to ensure that Iron.io accounts, services,  and projects are secured against unauthorized access. Only account owners and accounts that queues have been shared with can access the queues, workers, and caches they create.

We use SSL to protect data in transit and provide a high levels of security for the data within the system. We have a number of customers using us for transactional data and believe we offer a secure, reliable solution for cloud messaging. We do, however, recommend that for especially sensitive data, clients do client-level encryption of data payloads so that it has added protection even when data is at rest.

We’re happy to discuss these measures as well as custom plans that can address areas that include SLAs, architectural help and enhanced support, and custom data retention options.</p>
</div>

<div id="MQfaq-15">
<h3>What happens once the set number of api requests, compute hours, or data volume in a plan isreached?</h3>
<p>It’s up to you. Service can continue seamlessly on a usage-based rates or you can set a hard stop at the plan amount. The default is unlimited usage. See each service for the usage-based rates.</p>
</div>

<div id="MQfaq-16">
<h3>What happens if you turn the default off and hit the plan amount?</h3>
<p>If you turn the default off and hit the plan limit, then subsequent API requests will return errors. (Specifically, the services will return an HTTP status code of 403.)</p>
</div>

<div id="MQfaq-17">
<h3>Can you adjust the plan limits?</h3>
<p>You can either increase or decrease your plans at will. You can also turn on unlimited usage and you'll be billed at usage-based rates for amounts over the plan.</p>
</div>

<div id="MQfaq-18">
<h3>
Will you be notified as you reach or exceed the plan amounts?</h3>
<p>Yes. You’ll be notified on a regular basis of your usage as well as if you get close and/or reach the plan amounts. Note that you can switch plans at any time.</p>
</div>

<div id="MQfaq-19">
<h3>Can I pay at usage-based rates?</h3>
<p>
If you’re a heavy user and have specific needs, please let us know and we’d be happy to work with you to customize a plan that fits your needs. Contact us for more details.</p>
</div>

<div id="Workerfaq-1">
	<h3>What is IronWorker?</h3>
	<p>An easy-to-use scalable task queue that gives cloud developers a simple way to offload front-end tasks, run scheduled jobs, and process tasks in the background and at scale.</p>
</div>
<div id="Workerfaq-2">
	<h3>What are the advantages of IronWorker vs Heroku Workers, Celery, or Resque?</h3>
	<p>Our workers give you a wide range of flexibility and scalability that other services can't match.
	We support a wide range of languages. Python, Ruby, PHP, .NET, Java, Clojure, Node.js, Go, and binary code! Have a up to the second reporting and analytics though our Heads Up Display (HUD). By not having to manage your own servers, queues, and schedulers, we allow you scale accordingly to your needs, only processing time is counted.<a href="http://www.iron.io/worker#comparison">See our Comparison Chart</a> </p>
</div>
<div id="Workerfaq-3">
	<h3>What client libraries are available for IronWorker?</h3>
	<p>We current have 6 official client libraries in Ruby, PHP, Python, Java, Node.js, and Go, as well as a unofficial client library for .Net.
	</p>
	<ul>
	<li>Ruby: <a href             ="https://github.com/iron-io/iron_worker_ruby_ng">http://github.com/iron-io/iron_worker_ruby_ng</a></li>
	<li>PHP: <a href              ="https://github.com/iron-io/iron_worker_php">http://github.com/iron-io/iron_worker_php</a></li>
	<li>Python: <a href           ="https://github.com/iron-io/iron_worker_python">http://github.com/iron-io/iron_worker_python</a></li>
	<li>Java: <a href             ="https://github.com/iron-io/iron_worker_java">http://github.com/iron-io/iron_worker_java</a></li>
	<li>Node: <a href             ="https://github.com/iron-io/iron_worker_node">http://github.com/iron-io/iron_worker_node</a></li>
	<li>Go: <a href               ="https://github.com/iron-io/iron_go">http://github.com/iron-io/iron_go</a></li>
	<li>.NET(unofficial): <a href ="https://github.com/odeits/IronTools">http://github.com/odeits/IronTools"</a></li>
	</ul>

	<div id="Workerfaq-5">
	<h3>How do I access my worker's logs and what is printed in them?</h3>
	<p>IronWorker tasks print everything that would go to stdout (Standard Output) so the logs will very greatly depending on the worker's code and payload. 

	<p>To access your IronWorker logs, log into your account and click the IronWorker icon on the top right. From there, select the task you need the logs from. From this page, you can click the log icon
	<br /><img src='https://raw.githubusercontent.com/iron-io/docs/gh-pages/images/log.png' style="width:90%" />

	<p>Or, click the task's label and access it from the task details.
	
</div>


<div id="Cachefaq-1">
	<h3>What is IronCache?</h3>
	<p>IronCache is an elastic and durable key/value store that’s perfect for applications
that need to share state, pass data, and coordinate activity between processes and
devices. Reduce database load by making use of a high-performance middle tier for
asynchronous processing and communication.</p>
</div>


<p>We keep an active presence on Twitter as <a href ="http://twitter.com/getiron">@getiron</a>, on Google+ as <a href="https://plus.google.com/107979826672004784735">+Iron.io</a>, and on Slack at <a href="http://get.iron.io/slack">get.iron.io/slack</a>. Follow us, circle us, tweet us, or chat us up. We'd love to hear from you.
